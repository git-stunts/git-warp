<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lesson 3: No Room for Conflict</title>
  <link rel="stylesheet" href="assets/style.css">
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm/dist/index.min.js"></script>
</head>
<body>
  <header>
    <h1>CHRONOS CLASH</h1>
    <a href="index.html" style="color: var(--text-2); text-decoration: none;">&larr; BACK TO HUB</a>
  </header>

  <main id="app">
    <section class="card">
      <h2>Lesson 3: No Room for Conflict</h2>
      <p>In a normal Git repo, if Alice and Bob edit the same line, you get a <strong>Merge Conflict</strong>. In <strong>Chronos Clash</strong>, conflicts are mathematically impossible.</p>
      
      <p>We use <strong>CRDTs (Conflict-free Replicated Data Types)</strong>. Specifically:</p>
      <ul>
        <li><strong>OR-Set (Observed-Remove Set):</strong> If Alice adds a character and Bob removes it at the same time, the ADD wins. Bob only removes what he has already "observed".</li>
        <li><strong>LWW (Last-Write-Wins):</strong> For properties like a character's name, we use a total order (Lamport Clock + Writer ID) to decide who wins. Everyone agrees on the winner without talking to each other.</li>
      </ul>

      <div class="card">
        <h3>Multi-Writer Simulation</h3>
        <p>Simulate Alice and Bob making concurrent edits. Watch how the <strong>Join Reducer</strong> merges them into a consistent state!</p>
        
        <div style="display: flex; gap: var(--size-3); margin-bottom: var(--size-4);">
          <button @click="aliceEdit" class="btn-primary" style="background: var(--pink-7);">ALICE ADDS CHARACTER</button>
          <button @click="bobEdit" class="btn-primary" style="background: var(--teal-7);">BOB ADDS CHARACTER</button>
          <button @click="sync" class="btn-primary">SYNC ALL WRITERS</button>
        </div>
        
        <div class="viz-container" id="viz"></div>

        <div class="card" v-if="mergedState.length > 0">
          <h4>Materialized View (World State):</h4>
          <ul>
            <li v-for="char in mergedState" :key="char.id"><strong>{{ char.name }}</strong> (Added by {{ char.writer }})</li>
          </ul>
        </div>
      </div>

      <div class="lesson-nav">
        <a href="lesson-2.html" class="btn-primary" style="background: var(--surface-3);">PREVIOUS</a>
        <a href="lesson-4.html" class="btn-primary">NEXT: X-RAY VISION &rarr;</a>
      </div>
    </section>
  </main>

  <script>
    const { createApp } = Vue
    const hpccWasm = window["@hpcc-js/wasm"];

    createApp({
      data() {
        return {
          aliceTicks: [],
          bobEditCount: 0,
          aliceEditCount: 0,
          bobTicks: [],
          synced: true,
          mergedState: []
        }
      },
      methods: {
        aliceEdit() {
          this.aliceEditCount++;
          this.aliceTicks.push({ id: `A${this.aliceEditCount}`, writer: 'Alice', name: `Knight ${this.aliceEditCount}` });
          this.synced = false;
          this.renderGraph();
        },
        bobEdit() {
          this.bobEditCount++;
          this.bobTicks.push({ id: `B${this.bobEditCount}`, writer: 'Bob', name: `Mage ${this.bobEditCount}` });
          this.synced = false;
          this.renderGraph();
        },
        sync() {
          this.synced = true;
          this.mergedState = [...this.aliceTicks, ...this.bobTicks];
          this.renderGraph();
        },
        async renderGraph() {
          let dot = `digraph G {
            rankdir=TB;
            bgcolor="transparent";
            node [shape=box, style=filled, fillcolor="#334155", fontcolor="white", fontname="Inter"];
            edge [color="#94a3b8"];
            
            Root [label="U0 (Shared Root)", fillcolor="#1e293b"];
          `;

          // Alice's Chain
          let prevA = "Root";
          this.aliceTicks.forEach(t => {
            dot += `${t.id} [label="Alice: ${t.name}", fillcolor="#9d174d"];
`;
            dot += `${prevA} -> ${t.id};
`;
            prevA = t.id;
          });

          // Bob's Chain
          let prevB = "Root";
          this.bobTicks.forEach(t => {
            dot += `${t.id} [label="Bob: ${t.name}", fillcolor="#0f766e"];
`;
            dot += `${prevB} -> ${t.id};
`;
            prevB = t.id;
          });

          if (this.synced && (this.aliceTicks.length > 0 || this.bobTicks.length > 0)) {
            dot += `Merged [label="Merged State
(Materialized)", fillcolor="#1e293b", shape=doubleoctagon];
`;
            if (prevA !== "Root") dot += `${prevA} -> Merged;
`;
            if (prevB !== "Root") dot += `${prevB} -> Merged;
`;
          }

          dot += "}";
          
          const vizElement = document.getElementById("viz");
          const svg = await hpccWasm.graphviz.layout(dot, "svg", "dot");
          vizElement.innerHTML = svg;
        }
      },
      mounted() {
        this.renderGraph();
      }
    }).mount('#app')
  </script>
</body>
</html>
